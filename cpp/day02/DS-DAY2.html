<!DOCTYPE html>
<html>
<head>
<title>DS-DAY2.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="searching">Searching :</h1>
<ul>
<li>To search a key ele in a given collection/list of elements.</li>
</ul>
<h2 id="linear-search">Linear Search:</h2>
<ol>
<li>Also called as &quot;sequential search&quot;.</li>
<li>It sequentially checks each element of the list until the match  is found or the whole list has been searched.</li>
</ol>
<pre class="hljs"><code><div>  <span class="hljs-function">Algorithm <span class="hljs-title">LinearSearch</span><span class="hljs-params">(A, n, key)</span>
  </span>{
  	<span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> index = <span class="hljs-number">1</span> ; index &lt;= SIZE ; index++ )
  	{
  		<span class="hljs-keyword">if</span>( A[ index ] == key )
  			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  	}
  	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
</div></code></pre>
<pre class="hljs"><code><div>* Best case 
   - when key is found at first pos then algo does only one comparison,
     time complexity of an algo in this case = O(1).

      Big Omega(1)
   

* Worst case 
   - when either key is exists at last position or key does not exists
     algo does max &quot;n&quot; no. of comparisons whereas &quot;n&quot; size of an array,
     in this case time complexity of an algo = O(n).

     Big Oh(n)
  	
* Average case 
   - if key is exists at in between position the algo takes neither
     minimum nor max time to complete its execution, in this case time 
     complexity of an algo = O(n/2) =&gt; O(n).

     Big Theta(n)
</div></code></pre>
<h2 id="binary-search">Binary Search:</h2>
<ol>
<li>Also called as &quot;logarithmic search&quot; or &quot;half interval search&quot;</li>
<li>This algo follows &quot;divide-and-conquer&quot; stratergy.</li>
<li>To apply binary search prerequisite is collection/list of elements must be in a
sorted manner.</li>
<li>In the first iteration -- mid position gets calculated and key ele gets compared</li>
<li>With ele at mid position, if key ele is found then it will be the best case,
otherwise array gets divided logically into two sub array's left subarray and
right sub array.</li>
<li>If key ele is smaller than mid position ele then key ele gets searched into the
left sub array only, by skipping the whole right sub array checking, or, if key ele
is greater than mid position ele then key ele gets searched into the right sub</li>
<li>Array only by skipping whole left sub array.</li>
<li>The logic repeats either till key ele is not found or till size of an array is
less than one.</li>
<li>If key ele is found at mid position in the very first iteration then no. of
comparisons are &quot;1&quot; and it is considered as a best case, in this algo takes O(1)
time, otherwise it takes O(log n) time.</li>
</ol>
<pre class="hljs"><code><div>   <span class="hljs-function">Algorithm <span class="hljs-title">BinarySearch</span><span class="hljs-params">(A, n, key)</span>
   </span>{
   	left = <span class="hljs-number">0</span>;
   	right = n<span class="hljs-number">-1</span>;
   	
   	<span class="hljs-comment">//till array/subarray is valid</span>
   	<span class="hljs-keyword">while</span>( left &lt;= right )
   	{
   		mid = (left+right)/<span class="hljs-number">2</span>;
   		
   		<span class="hljs-keyword">if</span>( key == A[mid] )
   			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
   		
   		<span class="hljs-keyword">if</span>( key &lt; A[mid] )
   			 right = mid<span class="hljs-number">-1</span>;
   		<span class="hljs-keyword">else</span>
   			left = mid+<span class="hljs-number">1</span>
   	}
   	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
   }
</div></code></pre>
<ol start="10">
<li>As in every iteration this algo does 1 comparison and divides array into
two sub arrays and key ele gets searched either one of the subarray, i.e. after
every iteration it search space is divide almost by half, and hence we can write
following recurrent equation for binary search, and can use substitution method
to calculate its time complexity:</li>
</ol>
<ul>
<li>Recurrent Equation:</li>
</ul>
<pre class="hljs"><code><div>   for n = 1
   T(n) = T(1) + 1
   i.e. running time of an algo is O(1). --- trivial case
   
   for n &gt; 1
   T(n) = T(n/2)+ 1 ..... (I)
   to get the value of T(n/2) put  n = n/2 in eq-I we get,
   =&gt; T(n/2) = T( n/2 / 2 ) + 1
   =&gt; T(n/2) = T(n/4) + 1 .....(II)
   
   substitute the value of T(n/2) in eq-I we get,
   =&gt; T(n) = [ T(n/4) + 1 ] + 1
   =&gt; T(n) = T(n/4) + 2 .....(III)
   
   
   to get the value of T(n/2) put n = n/2 in eq-II we get,
   =&gt; T( (n/2) / 2 ) = T( (n/4) / 2 ) + 1
   =&gt; T(n/4) = T(n/8) + 1 .... (IV)
   
   substitute the value of T(n/4) in eq-III we get,
   =&gt; T(n/4) = [ T(n/8) + 1 ] + 2
   =&gt; T(n/4) = T(n/8) + 3 ......(V)
   
   .
   .
   after k iterations:
   
   T(n) = T(n/2^k) + k
   
   for n = 2^k
   log n = log 2^k .... by taking log on both side
   log n = k log 2
   therefore, k = log n
   =&gt; T(n) = T(2^k/2^k) + log n
   =&gt; T(n) = T(1) + log n
   =&gt; T(n) = log n
</div></code></pre>
<pre><code>and hence, T(n) = O(log n).
</code></pre>
<h3 id="difference-between-linear-search-and-binary-search">Difference between Linear Search and Binary Search:</h3>
<ul>
<li>
<p>In linear search after every iteration search space is reduced by 1 i.e. (n-1)
and in binary search search space is reduced by half of elements i.e. by (n/2).</p>
</li>
<li>
<p>Worst case time complexity of linear search is O(n) and of binary search is
O(log n) hence binary search is efficient than linear search.</p>
</li>
<li>
<p>Binary search cannot be applied on linked list.</p>
</li>
</ul>
<p>==============================================================================</p>
<h1 id="sorting">Sorting:</h1>
<h3 id="features-of-sorting-algos">Features of sorting algo's:</h3>
<ul>
<li>Adaptive
<ul>
<li>When a sorting algo works efficiently for already sorted input
sequence then it is reffered as an adaptive.</li>
</ul>
</li>
<li>Inplace
<ul>
<li>If a sorting algo do not takes extra space then it is reffered as
inplace.</li>
</ul>
</li>
<li>Stable
<ul>
<li>If the relative order of two ele's having same key remains same
after sorting then such sorting algo is reffered as stable.</li>
</ul>
</li>
</ul>
<h2 id="selection-sort">Selection Sort:</h2>
<ul>
<li>Inplace comparison sort</li>
<li>This algo divides the list logically into two sublists, first list contains all
elements and another list is empty.</li>
<li>In the first iteration -- first element from the first list is selected and gets
compared with remaining all ele's in that list, and the smallest ele can be added
into the another list, so after first iteration second list contains the smallest
ele in it.</li>
<li>In the second iteration -- second element from the first list is selected and
gets compared with remaining all ele's in that list and the smallest amongst them
can be added into the another list at next position, so in second iteration the
second smallest element gets added into the another list next to the smallest one,
and so on.....</li>
<li>So in max (n-1) no. of iterations all elements from first list gets added into
the another list (which was initially empty) in a sorted manner and we will get
all elements in a collection/list in a sorted manner.</li>
<li>In every iteration one element gets selected and gets compared with remaining</li>
<li>best case, worst case and average case time complexity of selection sort algo is
O(n^2).</li>
</ul>
<h3 id="advantages">advantages:</h3>
<ol>
<li>Simple to implement</li>
<li>Inplace</li>
</ol>
<h3 id="disadvantages">disadvantages:</h3>
<ol>
<li>Not efficient for larger input size collection of ele's array/list.</li>
<li>Not adaptive i.e. not efficient for already sorted input sequence.</li>
</ol>
<h2 id="bubble-sort">Bubble Sort:</h2>
<ul>
<li>Sometimes reffered to as &quot;sinking sort&quot;.</li>
<li>This algo divides the list logically into two sublists, initially first list
contains all elements and another list is empty.</li>
<li>In the first iteration -- the largest element from first list gets selected and
gets added into the another list at last position.</li>
<li>In the second iteration -- largest element from the ele's left in a first list
is selected and gets added into the second list at second last position and so
on....</li>
<li>So in max (n-1) no. of iterations all elements from first list gets added into
the another list (which was initially empty) in a sorted manner from last position
to first position and we will get all elements in a collection/list in a sorted
manner.
OR</li>
<li>Ele's at consecutive locations gets compared with each other of they are not in
order then they gets swapped otherwise their position remains same.</li>
</ul>
<h3 id="best-case">best case</h3>
<ul>
<li>If array ele's are already sorted then this algo takes O(n) time</li>
</ul>
<h3 id="worst-case-and-average-case">worst case and average case</h3>
<ul>
<li>Time complexity of bubble sort algo is O(n^2).</li>
</ul>
<h3 id="advantages">advantages:</h3>
<ul>
<li>Simple to implement</li>
<li>Inplace - do not takes extra space for sorting ele's</li>
<li>Can be implement as an adaptive</li>
<li>Highly stable</li>
</ul>
<h3 id="disadvantages">disadvantages:</h3>
<ul>
<li>Not efficient for larger input size collection of ele's array/list.</li>
<li>Not adaptive in nature but can be implement as an adaptive</li>
</ul>

</body>
</html>
